---
title: "Homework 8"
date: 2022-11-22
categories:
  - homework
tags:
  - c#
  - polar
---
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


# (A) Application
### Consider $$R,\Theta$$ uniform random variables and use them to determine points on a plane as follows: use $$R$$ as distance from the origin and $$\Theta$$ as a random angle between $$0$$ and $$360Â°$$. Determine the empirical distribution of $$X$$ and $$Y$$ (the cartesian coordinates of the points). Search on the web about this problem.

In the following program, two examples are shown:
1. The first example uses uniformly random polar coordinates to generate the points.
```csharp
public List<PointF> UniformPolar(int n)
{
    List<PointF> points = new();
    Random r = new();

    for (int i = 0; i < n; i++)
    {
        double radius = r.NextDouble();
        double theta = 2 * Math.PI * r.NextDouble();
        double x = radius * Math.Cos(theta);
        double y = radius * Math.Sin(theta);
        points.Add(new PointF((float)x, (float)y));
    }
    return points;
}
```
2. The second example uses the Marsaglia method, which extracts two uniform random variables $$X$$ and $$Y$$ in the range $$(-1,1)$$ and checks if $$X^2+Y^2\leq 1$$ (if the point is in the unit circle) until it finds a point that satisfies the condition.
```csharp
public List<PointF> MarsagliaPolar(int n)
{
    List<PointF> points = new();
    Random r = new();

    for (int i = 0; i < n; i++)
    {
        double x, y;
        do
        {
            x = 2 * r.NextDouble() - 1;
            y = 2 * r.NextDouble() - 1;
        } while (x * x + y * y >= 1);
        points.Add(new PointF((float)x, (float)y));
    }
    return points;
}
```

The first method produces points that are more concentrated around the center of the circle, while the second method produces points that are more uniformly distributed over the whole surface of the unit circle.

![Random points inside of a circle]({{ site.baseurl }}/assets/hw8/circles.png)

```csharp
public void Draw(int i)
{
    int n = 50000;

    int border = 5;
    int topBorder = 48;
    int boxHeight = pic.Height / 2 - topBorder;
    Rectangle r = new(border, topBorder * (i+1) + i * boxHeight,
        pic.Width - 2 * border, boxHeight);

    // Divide the area in three columns:
    // + A square for the scatter plot
    // + Two rectangles for the distribution histograms
    Rectangle sr = new(r.Left, r.Top, r.Height, r.Height);
    Rectangle xr = new(r.Left + r.Height, r.Top, (r.Width - r.Height) / 2, r.Height);
    Rectangle yr = new(r.Left + r.Width/2 + r.Height/2, r.Top, (r.Width - r.Height) / 2, r.Height);

    g.FillRectangle(Brushes.White, sr);
    g.FillRectangle(Brushes.White, xr);
    g.FillRectangle(Brushes.White, yr);

    // Draw the text on top of every box
    Font drawFont = new Font("Tahoma", topBorder/4);
    SolidBrush drawBrush = new SolidBrush(Color.Black);
    StringFormat drawFormat = new StringFormat();
    drawFormat.FormatFlags = StringFormatFlags.NoWrap;
    g.DrawString("Scatter Plot", drawFont, drawBrush, sr.Left, r.Top - topBorder/2, drawFormat);
    g.DrawString("X Distribution", drawFont, drawBrush, xr.Left, r.Top - topBorder/2, drawFormat);
    g.DrawString("Y Distribution", drawFont, drawBrush, yr.Left, r.Top - topBorder/2, drawFormat);
    // Draw the method on top
    String method = i == 0 ? "Uniform in Polar" : "Marsiglia Method";
    g.DrawString(method + "  ------------", drawFont, drawBrush, sr.Left, r.Top - topBorder, drawFormat);

    // Get the points
    List<PointF> points = i == 0 ? UniformPolar(n) : MarsagliaPolar(n);
    List<float> xs = new();
    List<float> ys = new();

    // Draw the scatter plot
    Brush translucid = new SolidBrush(Color.FromArgb(128, 0, 128, 224));
    // 1. Draw each point
    foreach (PointF point in points) {
        xs.Add(point.X);
        ys.Add(point.Y);

        // Rescale x and y to fit in the square
        float x = Map(point.X, -1, 1, sr.Left, sr.Left + (float)sr.Width);
        float y = Map(point.Y, -1, 1, sr.Top, sr.Top + (float)sr.Height);

        // Plot them as circles
        g.FillEllipse(translucid, x-1, y-1, 3, 3);
    }
    // 2. Draw the axes
    g.DrawLine(Pens.Black, sr.Left + sr.Width / 2, sr.Top, sr.Left + sr.Width / 2, sr.Top + sr.Height);
    g.DrawLine(Pens.Black, sr.Left, sr.Top + sr.Height/2, sr.Left + sr.Width, sr.Top + sr.Height/2);

    // Get the distributions
    List<float> xdist = ComputeDistribution(xs, 1f / xr.Width);
    List<float> ydist = ComputeDistribution(ys, 1f / yr.Width);


    PlotDistribution(xr, true, xdist, 10);
    PlotDistribution(yr, true, ydist, 10);

    pic.Refresh();
}
```

`Draw` is called both with `0` and `1` as argument. The methods `ComputeDistribution`, `Map` and `PlotDistribution` are the same as in the previous exercises.